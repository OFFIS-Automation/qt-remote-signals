#include "BaseClassWriter.h"

#include <QDebug>

BaseClassWriter::BaseClassWriter(const ConfigFileReader &parser,
                                 const QString &baseName, const QDir &targetDir)
    : mParser(parser)
{
    mClassName = baseName;
    mTargetDir = targetDir;
}

void BaseClassWriter::writeClient(bool skipDateCheck)
{
    QString baseClassName = mClassName + "ClientBase";
    if (skipDateCheck || needsGeneration(baseClassName)){
        writeHeader(baseClassName, true);
        writeImplementation(baseClassName, true);
    } else {
        qWarning() << "Client source and header is newer than definition "
                      "file; omiting file generation";
    }
}

void BaseClassWriter::writeServer(bool skipDateCheck)
{
    QString baseClassName = mClassName + "ServerBase";
    if (skipDateCheck || needsGeneration(baseClassName)){
        writeHeader(baseClassName, false);
        writeImplementation(baseClassName, false);
    } else {
        qWarning() << "Server source and header is newer than definition "
                      "file; omiting file generation";
    }
}

bool BaseClassWriter::needsGeneration(const QString &className)
{
    QFileInfo headerInfo(mTargetDir.absoluteFilePath(className + ".h"));
    QFileInfo sourceInfo(mTargetDir.absoluteFilePath(className + ".cpp"));
    bool noUpdateNeeded = headerInfo.exists() && headerInfo.lastModified() > mParser.lastConfigUpdate();
    noUpdateNeeded &= sourceInfo.exists() && sourceInfo.lastModified() > mParser.lastConfigUpdate();
    return !noUpdateNeeded;
}

void BaseClassWriter::writeHeader(const QString &className, bool isClient)
{
    const ConfigFileReader::ID &id = mParser.id();
    QFile file(mTargetDir.absoluteFilePath(QString("%1.h").arg(className)));
    file.open(QFile::WriteOnly);
    QTextStream stream(&file);
    stream << "//qtRemoteSignals auto generated file" << endl;
    stream << "//do not edit this file; if needed subclass it or create a "
              "decorator" << endl;
    stream << QString("//md5 hash: %1%2")
                  .arg(QString::number(id.id1, 16), QString::number(id.id2, 16))
           << endl;
    stream << "#ifndef " << className.toUpper() << "_H" << endl;
    stream << "#define " << className.toUpper() << "_H" << endl
           << endl;
    stream << "#include \"RemoteSignals.h\"" << endl;
    foreach (const QString &includeStr, mParser.includes())
        stream << "#include " << includeStr << endl;
    stream << endl;
    stream << "class " << className << " : public RemoteSignals" << endl;
    stream << "{" << endl;
    stream << "\tQ_OBJECT" << endl;
    stream << "public:" << endl;
    if (isClient)
        stream << "\t" << className << "(QIODevice* writeDevice, QIODevice* "
                                       "readDevice = 0, bool initialize = "
                                       "false);" << endl;
    else
        stream << "\t" << className << "(QIODevice* readDevice, QIODevice* "
                                       "writeDevice = 0, bool initialize = "
                                       "false);" << endl;
    stream << "signals:" << endl;
    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse == isClient && !method.isBlocking)
            stream << "\tvoid " << method.signature() << ";" << endl;
    }
    stream << endl;
    stream << "public slots:" << endl;
    stream << "//remote signals" << endl;
    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse != isClient && !method.isBlocking)
            stream << "\t" << method.returnType() << " " << method.signature()
                   << ";" << endl;
    }
    stream << endl;
    stream << "public slots:" << endl;
    stream << "// blocking methods" << endl;
    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse != isClient && method.isBlocking)
            stream << "\t" << method.returnType() << " " << method.signature()
                   << ";" << endl;
        if (method.isReverse == isClient && method.isBlocking)
            stream << "\tvirtual " << method.returnType() << " "
                   << method.signature() << " = 0;" << endl;
    }
    stream << endl;
    stream << "private:" << endl;
    stream << "\tvoid processRemoteInputs(const QByteArray& data);" << endl;

    if(!isClient) {
        foreach (const Method &method, mParser.methods()) {
            if (method.isReverse == false && method.isBlocking)
               stream << "\t friend class " << className << "Runnable_" << method.name << ";" << endl;
        }
    }

    stream << "};" << endl
           << endl;
    stream << "#endif //" << className.toUpper() << "_H" << endl;
}

void BaseClassWriter::writeImplementation(const QString &className,
                                          bool isClient)
{
    const ConfigFileReader::ID &id = mParser.id();
    QString ns = className + "::";
    QFile file(mTargetDir.absoluteFilePath(QString("%1.cpp").arg(className)));
    file.open(QFile::WriteOnly);
    QTextStream stream(&file);
    stream << "//qtRemoteSignals auto generated file" << endl;
    stream << "//do not edit this file; if needed subclass it or create a "
              "decorator" << endl
           << endl;
    stream << "#include \"" << className << ".h\"" << endl
           << endl;
    if(!isClient)
        writeRunnables(stream, className);
    if (isClient)
        stream << ns << className << "(QIODevice* writeDevice, QIODevice* "
                                     "readDevice, bool initialize)" << endl;
    else
        stream << ns << className << "(QIODevice* readDevice, QIODevice* "
                                     "writeDevice, bool initialize)" << endl;
    stream << "\t: RemoteSignals(Q_UINT64_C(0x" + QString::number(id.id1, 16) +
                  "),Q_UINT64_C(0x" + QString::number(id.id2, 16) +
                  "), readDevice, writeDevice, initialize)" << endl;
    stream << "{}" << endl
           << endl;

    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse != isClient)
            writeMethod(stream, method, ns);
    }
    stream << "void " << ns << "processRemoteInputs(const QByteArray& data)"
           << endl;
    stream << "{" << endl;
    stream << "\tQDataStream stream(data);" << endl;
    stream << "\tint remoteSignalVersion = 0;" << endl;
    stream << "\tquint64 remoteSignalGid1 = 0;" << endl;
    stream << "\tquint64 remoteSignalGid2 = 0;" << endl;
    stream << "\tint remoteSignalMethodId = 0;" << endl;
    stream << "\tstream >> remoteSignalVersion >> remoteSignalGid1 >> "
              "remoteSignalGid2 >> remoteSignalMethodId;" << endl;
    stream << "\tRemoteSignals::checkId(remoteSignalVersion, remoteSignalGid1, "
              "remoteSignalGid2);" << endl
           << endl;
    QStringList mBlockIds;
    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse == isClient)
            writeMethodParsing(stream, method, className);
        else if (isClient && method.isBlocking) {
            mBlockIds << QString::number(method.id);
        }
    }
    stream << endl;
    if (!mBlockIds.empty()) {
        stream << "\tif(remoteSignalMethodId == ";
        stream << mBlockIds.join("\n\t\t|| remoteSignalMethodId ==") << ")"
               << endl;
        stream << "\t{" << endl;
        stream << "\t\tquint64 callUid;" << endl;
        stream << "\t\tstream >> callUid;" << endl;
        stream << "\t\tqint64 pos = stream.device()->pos();" << endl;
        stream << "\t\tQMutexLocker lock(&mUidMutex);" << endl;
        stream << "\t\tmResponses[callUid] = data.mid(pos);" << endl;
        stream << "\t\treturn;" << endl;
        stream << "\t}" << endl;
    }
    stream << "\tRemoteSignals::handleError(remoteSignalMethodId);" << endl;
    stream << "}" << endl;
}

void BaseClassWriter::writeRunnables(QTextStream &stream, const QString& className)
{
    bool includeWritten = false;
    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse == false && method.isBlocking)
        {
            if(!includeWritten)
            {
                stream << "#include <QRunnable>" << endl << endl;
            }
            QString name = className + "Runnable_" + method.name;
            stream << "class " << name << " : public QRunnable" << endl;
            stream << "{" << endl;
            stream << "public:" << endl;
            stream << "\t" << name << "(" << className << "& base, quint64 callUid";
            foreach(const Parameter& param, method.params)
            {
                stream << ", "  << param.signature();
            }
            stream << ")" << endl;

            stream << "\t\t: m_base(base), m_callUid(callUid) ";
            foreach(const QString& paramName, method.paramNames())
            {
                stream << ", m_"  << paramName << "(" << paramName << ")";
            }
            stream << "{}" << endl;
            stream << "private:" << endl;
            stream << "\tvoid run() {" << endl;
            stream << "\t\t";
            if(method.returnType() != "void")
                stream << method.returnType()<< " returnValue = m_base.";
            if(method.paramNames().empty())
            {
            stream << method.name << "();" << endl;
            } else {
            stream << method.name << "(m_"
                   << method.paramNames().join(", m_") << ");" << endl;
            }
            stream << "\t\tQByteArray msgData;" << endl;
            stream << "\t\tQDataStream sendStream(&msgData, QIODevice::WriteOnly);"
                   << endl;
            stream << "\t\tsendStream << m_base.RemoteSignals::version() << m_base.RemoteSignals::gid1() "
                      "<< m_base.RemoteSignals::gid2() << (int)" << QString::number(method.id)
                   << ";" << endl;
            stream << "\t\tsendStream << m_callUid;" << endl;
            if(method.returnType() != "void")
                stream << "\t\tsendStream << returnValue;" << endl;
            stream << "\t\tm_base.transmitSignal(msgData);" << endl;
            stream << "\t}" << endl;
            stream << "\t" << className << "& m_base;" << endl;
            stream << "\tquint64 m_callUid;" << endl;
            foreach(const Parameter& param, method.params)
            {
                stream << "\t" <<param.type << " m_" << param.name << ";" << endl;
            }
            stream << "};" << endl << endl;
        }
    }
}

void BaseClassWriter::writeMethod(QTextStream &stream, Method method,
                                  QString ns)
{
    stream << method.returnType() << " " << ns << method.signature() << endl;
    stream << "{" << endl;
    methodSendStaticStart(stream, method.id);
    foreach (const Parameter &param, method.params)
        stream << "\tsendStream << " << param.name << ";" << endl;
    if (method.isBlocking) {
        stream << "\tquint64 callUid = RemoteSignals::nextCallUid();" << endl;
        stream << "\tsendStream << callUid;" << endl;
    }
    stream << "\ttransmitSignal(msgData);" << endl;
    if (method.isBlocking) {
        stream << "\tconst QByteArray responseData = "
                  "RemoteSignals::waitForResponse(callUid);" << endl;
        if (method.returnType() != "void") {
            stream << "\t" << method.returnType() << " decodedResponse;"
                   << endl;
            stream << "\tQDataStream responseStream(responseData);" << endl;
            stream << "\tresponseStream >> decodedResponse;" << endl;
            stream << "\treturn decodedResponse;" << endl;
        }
    }
    stream << "}" << endl
           << endl;
}


void BaseClassWriter::writeMethodParsing(QTextStream &stream, Method method, const QString& className)
{
    stream << "\tif(remoteSignalMethodId == " << method.id << ") {" << endl;
    foreach (const Parameter &param, method.params)
        stream << "\t\t" << param.type << " " << param.name << ";" << endl;
    foreach (const Parameter &param, method.params)
        stream << "\t\tstream >> " << param.name << ";" << endl;
    if (method.isBlocking) {
        QString runnableName = className + "Runnable_" + method.name;
        QStringList paramNames;
        paramNames << "callUid";
        paramNames << method.paramNames();
        stream << "\t\tqint64 callUid;" << endl;
        stream << "\t\tstream >> callUid;" << endl;
        stream << "\t\t" << runnableName << "* runnable = new " << runnableName << "(*this, "
               << paramNames.join(", ") << ");" << endl;
        stream << "\t\tmThreadPool.start(runnable);" << endl;
    } else {
        stream << "\t\temit " << method.name << "("
               << method.paramNames().join(", ") << ");" << endl;
    }
    stream << "\t\treturn;" << endl;
    stream << "\t}" << endl;
}

void BaseClassWriter::methodSendStaticStart(QTextStream &stream, int methodId,
                                            int numtabs)
{
    QString tabs;
    for (int i = 0; i < numtabs; i++)
        tabs += "\t";
    stream << tabs << "QByteArray msgData;" << endl;
    stream << tabs << "QDataStream sendStream(&msgData, QIODevice::WriteOnly);"
           << endl;
    stream << tabs
           << "sendStream << RemoteSignals::version() << RemoteSignals::gid1() "
              "<< RemoteSignals::gid2() << (int)" << QString::number(methodId)
           << ";" << endl;
}
