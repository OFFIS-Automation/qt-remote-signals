#include "BaseClassWriter.h"

#include <QDebug>

BaseClassWriter::BaseClassWriter(const ConfigFileReader &parser,
                                 const QString &baseName, const QDir &targetDir)
    : mParser(parser)
{
    mClassName = baseName;
    mTargetDir = targetDir;
}

void BaseClassWriter::writeClient(bool skipDateCheck)
{
    QString baseClassName = mClassName + "ClientBase";
    if (skipDateCheck || needsGeneration(baseClassName)) {
        writeHeader(baseClassName, true);
        writeImplementation(baseClassName, true);
    } else {
        qWarning() << "Client source and header is newer than definition "
                      "file; omiting file generation";
    }
}

void BaseClassWriter::writeServer(bool skipDateCheck)
{
    QString baseClassName = mClassName + "ServerBase";
    if (skipDateCheck || needsGeneration(baseClassName)) {
        writeHeader(baseClassName, false);
        writeImplementation(baseClassName, false);
    } else {
        qWarning() << "Server source and header is newer than definition "
                      "file; omiting file generation";
    }
}


bool BaseClassWriter::needsGeneration(const QString &className)
{
    QFileInfo headerInfo(mTargetDir.absoluteFilePath(className + ".h"));
    QFileInfo sourceInfo(mTargetDir.absoluteFilePath(className + ".cpp"));
    bool noUpdateNeeded =
        headerInfo.exists() &&
        headerInfo.lastModified() > mParser.lastConfigUpdate();
    noUpdateNeeded &= sourceInfo.exists() &&
                      sourceInfo.lastModified() > mParser.lastConfigUpdate();
    return !noUpdateNeeded;
}

void BaseClassWriter::writeHeader(const QString &className, bool isClient)
{
    const ConfigFileReader::ID& id = mParser.id();
    QFile file(mTargetDir.absoluteFilePath(QString("%1.h").arg(className)));
    file.open(QFile::WriteOnly);
    QTextStream stream(&file);
    stream << "//qtRemoteSignals auto generated file" << endl;
    stream << "//do not edit this file; if needed subclass it or create a "
              "decorator" << endl;
    stream << QString("//md5 hash: %1%2")
              .arg(QString::number(id.id1, 16), QString::number(id.id2, 16))
           << endl;
    stream << "#ifndef " << className.toUpper() << "_H" << endl;
    stream << "#define " << className.toUpper() << "_H" << endl
           << endl;
    stream << "#include \"RemoteSignals.h\"" << endl;
    foreach (const QString &includeStr, mParser.includes())
        stream << "#include " << includeStr << endl;
    stream << endl;
    stream << "class " << className << " : public RemoteSignals" << endl;
    stream << "{" << endl;
    stream << "\tQ_OBJECT" << endl;
    stream << "public:" << endl;
    if (isClient)
        stream << "\t" << className << "(QIODevice* writeDevice, QIODevice* "
                                       "readDevice = 0, bool initialize = "
                                       "false);" << endl;
    else
        stream << "\t" << className << "(QIODevice* readDevice, QIODevice* "
                                       "writeDevice = 0, bool initialize = "
                                       "false);" << endl;
    stream << "signals:" << endl;
    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse == isClient && !method.isBlocking)
            stream << "\tvoid " << method.signature() << ";" << endl;
    }
    stream << endl;
    stream << "public slots:" << endl;
    stream << "//remote signals" << endl;
    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse != isClient && !method.isBlocking)
            stream << "\t" << method.returnType() << " " << method.signature()
                   << ";" << endl;
    }
    stream << endl;
    stream << "public slots:" << endl;
    stream << "// blocking methods" << endl;
    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse != isClient && method.isBlocking)
            stream << "\t" << method.returnType() << " " << method.signature()
                   << ";" << endl;
        if (method.isReverse == isClient && method.isBlocking)
            stream << "\tvirtual " << method.returnType() << " " << method.signature()
                   << " = 0;" << endl;
    }
    stream << endl;
    stream << "private:" << endl;
    stream << "\tvoid processRemoteInputs(const QByteArray& data);" << endl;
    stream << "};" << endl
           << endl;
    stream << "#endif //" << className.toUpper() << "_H" << endl;
}

void BaseClassWriter::writeImplementation(const QString &className, bool isClient)
{
    const ConfigFileReader::ID& id = mParser.id();
    QString ns = className + "::";
    QFile file(mTargetDir.absoluteFilePath(QString("%1.cpp").arg(className)));
    file.open(QFile::WriteOnly);
    QTextStream stream(&file);
    stream << "//qtRemoteSignals auto generated file" << endl;
    stream << "//do not edit this file; if needed subclass it or create a "
              "decorator" << endl;
    stream << "#include \"" << className << ".h\"" << endl;
    stream << endl;
    if (isClient)
        stream << ns << className << "(QIODevice* writeDevice, QIODevice* "
                                     "readDevice, bool initialize)" << endl;
    else
        stream << ns << className << "(QIODevice* readDevice, QIODevice* "
                                     "writeDevice, bool initialize)" << endl;
    stream << "\t: RemoteSignals(Q_UINT64_C(0x" + QString::number(id.id1, 16) +
              "),Q_UINT64_C(0x" + QString::number(id.id2, 16) +
              "), readDevice, writeDevice, initialize)" << endl;
    stream << "{}" << endl
           << endl;

    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse != isClient)
            writeMethod(stream, method, ns);
    }
    stream << "void " << ns << "processRemoteInputs(const QByteArray& data)"
           << endl;
    stream << "{" << endl;
    stream << "\tQDataStream stream(data);" << endl;
    stream << "\tint remoteSignalVersion = 0;" << endl;
    stream << "\tquint64 remoteSignalGid1 = 0;" << endl;
    stream << "\tquint64 remoteSignalGid2 = 0;" << endl;
    stream << "\tint remoteSignalMethodId = 0;" << endl;
    stream << "\tstream >> remoteSignalVersion >> remoteSignalGid1 >> "
              "remoteSignalGid2 >> remoteSignalMethodId;" << endl;
    stream << "\tRemoteSignals::checkId(remoteSignalVersion, remoteSignalGid1, "
              "remoteSignalGid2);" << endl
           << endl;
    QStringList mBlockIds;
    foreach (const Method &method, mParser.methods()) {
        if (method.isReverse == isClient)
            writeMethodParsing(stream, method);
        else if(isClient && method.isBlocking)
        {
            mBlockIds << QString::number(method.id);
        }
    }
    stream << endl;
    if(!mBlockIds.empty())
    {
        stream << "\tif(remoteSignalMethodId == ";
        stream << mBlockIds.join("\n\t\t|| remoteSignalMethodId ==") << ")" << endl;
        stream << "\t{" << endl;
        stream << "\t\tquint64 callUid;" << endl;
        stream << "\t\tstream >> callUid;" << endl;
        stream << "\t\tqint64 pos = stream.device()->pos();" << endl;
        stream << "\t\tQMutexLocker lock(&mUidMutex);" << endl;
        stream << "\t\tmResponses[callUid] = data.mid(pos);" << endl;
        stream << "\t\treturn;" << endl;
        stream << "\t}" << endl;

    }
    stream << "\tRemoteSignals::handleError(remoteSignalMethodId);" << endl;
    stream << "}" << endl;
}

void BaseClassWriter::writeMethod(QTextStream &stream, Method method, QString ns)
{
    stream << method.returnType() << " " << ns << method.signature() << endl;
    stream << "{" << endl;
    methodSendStaticStart(stream, method.id);
    foreach (const Parameter &param, method.params)
        stream << "\tsendStream << " << param.name << ";" << endl;
    if (method.isBlocking) {
        stream << "\tquint64 callUid = RemoteSignals::nextCallUid();" << endl;
        stream << "\tsendStream << callUid;" << endl;
    }
    stream << "\ttransmitSignal(msgData);" << endl;
    if (method.isBlocking) {
        stream << "\tconst QByteArray responseData = "
                  "RemoteSignals::waitForResponse(callUid);" << endl;
        if (method.returnType() != "void") {
            stream << "\t" << method.returnType() << " decodedResponse;"
                   << endl;
            stream << "\tQDataStream responseStream(responseData);" << endl;
            stream << "\tresponseStream >> decodedResponse;" << endl;
            stream << "\treturn decodedResponse;" << endl;
        }
    }
    stream << "}" << endl
           << endl;
}

void BaseClassWriter::writeMethodParsing(QTextStream &stream, Method method)
{
    stream << "\tif(remoteSignalMethodId == " << method.id << ") {" << endl;
    foreach (const Parameter &param, method.params)
        stream << "\t\t" << param.type << " " << param.name << ";" << endl;
    foreach (const Parameter &param, method.params)
        stream << "\t\tstream >> " << param.name << ";" << endl;
    if(method.isBlocking)
    {
        stream << "\t\tqint64 callUid;" << endl;
        stream << "\t\tstream >> callUid;" << endl;
        stream << "\t\t";
        if(method.returnType() != "void")
            stream << method.returnType()<< " returnValue = ";
        stream << method.name << "("
               << method.paramNames().join(", ") << ");" << endl;
        methodSendStaticStart(stream, method.id,2);
        stream << "\t\tsendStream << callUid;" << endl;
        if(method.returnType() != "void")
            stream << "\t\tsendStream << returnValue;" << endl;
        stream << "\t\ttransmitSignal(msgData);" << endl;
    }
    else
    {
        stream << "\t\temit " << method.name << "("
               << method.paramNames().join(", ") << ");" << endl;
    }
    stream << "\t\treturn;" << endl;
    stream << "\t}" << endl;
}

void BaseClassWriter::methodSendStaticStart(QTextStream &stream, int methodId, int numtabs)
{
    QString tabs;
    for(int i=0;i<numtabs;i++)
        tabs += "\t";
    stream << tabs << "QByteArray msgData;" << endl;
    stream << tabs << "QDataStream sendStream(&msgData, QIODevice::WriteOnly);" << endl;
    stream << tabs << "sendStream << RemoteSignals::version() << RemoteSignals::gid1() "
                      "<< RemoteSignals::gid2() << (int)" << QString::number(methodId)
           << ";" << endl;
}
